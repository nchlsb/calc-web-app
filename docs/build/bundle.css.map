{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\RangePips.svelte",
    "..\\..\\RangeSlider.svelte",
    "..\\..\\App.svelte",
    "..\\..\\TooltipFromAction.svelte"
  ],
  "sourcesContent": [
    "<script>\n\n  // range slider props\n  export let range = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n\n  // range pips / values props\n  export let pipstep = undefined;\n  export let all = true;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = v => v;\n\n  // stylistic props\n  export let focus = undefined;\n  export let percentOf = undefined;\n\n  $: pipStep = pipstep || ((max - min) / step >= ( vertical ? 50 : 100 ) ? (max - min) / ( vertical ? 10 : 20 ) : 1);\n\n  $: pipCount = parseInt((max - min) / (step * pipStep), 10);\n\n  $: pipVal = function(val) {\n    return min + val * step * pipStep;\n  };\n\n  $: isSelected = function(val) {\n    return values.some(v => v === val);\n  };\n\n  $: inRange = function(val) {\n    if (range === \"min\") {\n      return values[0] > val;\n    } else if (range === \"max\") {\n      return values[0] < val;\n    } else if (range) {\n      return values[0] < val && values[1] > val;\n    }\n  };\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --pip: var(--range-pip, lightslategray);\n    --pip-text: var(--range-pip-text, var(--pip));\n    --pip-active: var(--range-pip-active, darkslategrey);\n    --pip-active-text: var(--range-pip-active-text, var(--pip-active));\n    --pip-in-range: var(--range-pip-in-range, var(--pip-active));\n    --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));\n  }\n  :global(.rangePips) {\n    position: absolute;\n    height: 1em;\n    left: 0;\n    right: 0;\n    bottom: -1em;\n  }\n  :global(.rangePips.vertical) {\n    height: auto;\n    width: 1em;\n    left: 100%;\n    right: auto;\n    top: 0;\n    bottom: 0;\n  }\n  :global(.rangePips .pip) {\n    height: 0.4em;\n    position: absolute;\n    top: 0.25em;\n    width: 1px;\n    white-space: nowrap;\n  }\n  :global(.rangePips.vertical .pip) {\n    height: 1px;\n    width: 0.4em;\n    top: 0;\n    left: 0.25em;\n  }\n  :global(.rangePips .pip.selected) {\n    height: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected) {\n    height: 1px;\n    width: 0.75em;\n  }\n  :global(.rangePips .pipVal) {\n    position: absolute;\n    top: 0.4em;\n    transform: translate(-50%, 25%);\n  }\n  :global(.rangePips.vertical .pipVal) {\n    position: absolute;\n    top: 0;\n    left: 0.4em;\n    transform: translate(25%, -50%);\n  }\n  :global(.rangePips .pip.selected .pipVal) {\n    font-weight: bold;\n    top: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected .pipVal) {\n    top: 0;\n    left: 0.75em;\n  }\n  :global(.rangePips .pip, .rangePips .pipVal) {\n    transition: all 0.15s ease;\n  }\n  :global(.rangePips .pip) {\n    color: lightslategray;\n    color: var(--pip-text);\n    background-color: lightslategray;\n    background-color: var(--pip);\n  }\n  :global(.rangePips .pip.selected) {\n    color: darkslategrey;\n    color: var(--pip-active-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-active);\n  }\n  :global(.rangePips .pip.in-range) {\n    color: darkslategrey;\n    color: var(--pip-in-range-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-in-range);\n  }\n</style>\n\n<div class=\"rangePips\" class:focus class:vertical>\n  {#if ( all && first !== false ) || first }\n    <span\n      class=\"pip first\"\n      class:selected={isSelected(min)}\n      class:in-range={inRange(min)}\n      style=\"{vertical ? 'top' : 'left'}: 0%;\">\n      {#if all === 'label' || first === 'label'}\n        <span class=\"pipVal\">\n          {prefix}{formatter(min)}{suffix}\n        </span>\n      {/if}\n    </span>\n  {/if}\n  {#if ( all && rest !== false ) || rest}\n    {#each Array(pipCount + 1) as _, i}\n      {#if pipVal(i) !== min && pipVal(i) !== max}\n        <span\n          class=\"pip\"\n          class:selected={isSelected(pipVal(i))}\n          class:in-range={inRange(pipVal(i))}\n          style=\"{vertical ? 'top' : 'left'}: {percentOf(pipVal(i))}%;\">\n          {#if all === 'label' || rest === 'label'}\n            <span class=\"pipVal\">\n              {prefix}{formatter(pipVal(i))}{suffix}\n            </span>\n          {/if}\n        </span>\n      {/if}\n    {/each}\n  {/if}\n  {#if ( all && last !== false ) || last}\n    <span\n      class=\"pip last\"\n      class:selected={isSelected(max)}\n      class:in-range={inRange(max)}\n      style=\"{vertical ? 'top' : 'left'}: 100%;\">\n      {#if all === 'label' || last === 'label'}\n        <span class=\"pipVal\">\n          {prefix}{formatter(max)}{suffix}\n        </span>\n      {/if}\n    </span>\n  {/if}\n</div>\n",
    "<script>\n  import { spring } from \"svelte/motion\";\n  import { createEventDispatcher } from \"svelte\";\n  import RangePips from \"./RangePips.svelte\";\n\n  // range slider props\n  export let range = false;\n  export let pushy = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n  export let float = false;\n  export let hover = true;\n  export let disabled = false;\n\n  // range pips / values props\n  export let pips = false;\n  export let pipstep = undefined;\n  export let all = undefined;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let id = undefined;\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = (v) => v;\n  export let handleFormatter = formatter;\n\n  // stylistic props\n  export let precision = 2;\n  export let springValues = { stiffness: 0.15, damping: 0.4 };\n\n  // prepare dispatched events\n  const dispatch = createEventDispatcher();\n\n  // dom references\n  let slider;\n\n  // state management\n  let focus = false;\n  let handleActivated = false;\n  let handlePressed = false;\n  let keyboardActive = false;\n  let activeHandle = values.length - 1;\n  let startValue;\n  let previousValue;\n\n  // copy the initial values in to a spring function which\n  // will update every time the values array is modified\n  let springPositions;\n\n  $: {\n    // check that \"values\" is an array, or set it as array\n    // to prevent any errors in springs, or range trimming\n    if ( !Array.isArray( values ) ) {\n      values = [(max + min) / 2];\n      console.error( \"'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)\" );\n    }\n    // trim the range as needed\n    values = trimRange(values);\n    // clamp the values to the steps and boundaries set up in the slider\n    values = values.map((v) => alignValueToStep(v));\n    // update the spring function so that movement can happen in the UI\n    if ( springPositions ) {\n      springPositions.set(values.map((v) => percentOf(v)));\n    } else {\n      springPositions = spring( values.map((v) => percentOf(v)), springValues );\n    }\n  };\n\n  /**\n   * take in a value, and then calculate that value's percentage\n   * of the overall range (min-max);\n   * @param {number} val the value we're getting percent for\n   * @return {number} the percentage value\n   **/\n  $: percentOf = function (val) {\n    let perc = ((val - min) / (max - min)) * 100;\n    if (isNaN(perc) || perc <= 0) {\n      return 0;\n    } else if (perc >= 100) {\n      return 100;\n    } else {\n      return parseFloat(perc.toFixed(precision));\n    }\n  };\n\n  /**\n   * clamp a value from the range so that it always\n   * falls within the min/max values\n   * @param {number} val the value to clamp\n   * @return {number} the value after it's been clamped\n   **/\n  $: clampValue = function (val) {\n    // return the min/max if outside of that range\n    return val <= min ? min : val >= max ? max : val;\n  };\n\n  /**\n   * align the value with the steps so that it\n   * always sits on the closest (above/below) step\n   * @param {number} val the value to align\n   * @return {number} the value after it's been aligned\n   **/\n  $: alignValueToStep = function (val) {\n    // sanity check for performance\n    if (val <= min) {\n      return min;\n    } else if (val >= max) {\n      return max;\n    }\n\n    // find the middle-point between steps\n    // and see if the value is closer to the\n    // next step, or previous step\n    let remainder = (val - min) % step;\n    let aligned = val - remainder;\n    if (Math.abs(remainder) * 2 >= step) {\n      aligned += remainder > 0 ? step : -step;\n    }\n    // make sure the value is within acceptable limits\n    aligned = clampValue(aligned);\n    // make sure the returned value is set to the precision desired\n    // this is also because javascript often returns weird floats\n    // when dealing with odd numbers and percentages\n\n    return parseFloat(aligned.toFixed(precision));\n  };\n\n  /**\n   * helper func to get the index of an element in it's DOM container\n   * @param {object} el dom object reference we want the index of\n   * @returns {number} the index of the input element\n   **/\n  function index(el) {\n    if (!el) return -1;\n    var i = 0;\n    while ((el = el.previousElementSibling)) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * noramlise a mouse or touch event to return the\n   * client (x/y) object for that event\n   * @param {event} e a mouse/touch event to normalise\n   * @returns {object} normalised event client object (x,y)\n   **/\n  function normalisedClient(e) {\n    if (e.type.includes(\"touch\")) {\n      return e.touches[0];\n    } else {\n      return e;\n    }\n  }\n\n  /**\n   * check if an element is a handle on the slider\n   * @param {object} el dom object reference we want to check\n   * @returns {boolean}\n   **/\n  function targetIsHandle(el) {\n    const handles = slider.querySelectorAll(\".handle\");\n    const isHandle = Array.prototype.includes.call(handles, el);\n    const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));\n    return isHandle || isChild;\n  }\n\n  /**\n   * trim the values array based on whether the property\n   * for 'range' is 'min', 'max', or truthy. This is because we\n   * do not want more than one handle for a min/max range, and we do\n   * not want more than two handles for a true range.\n   * @param {array} values the input values for the rangeSlider\n   * @return {array} the range array for creating a rangeSlider\n   **/\n  function trimRange(values) {\n    if (range === \"min\" || range === \"max\") {\n      return values.slice(0, 1);\n    } else if (range) {\n      return values.slice(0, 2);\n    } else {\n      return values;\n    }\n  }\n\n  /**\n   * helper to return the slider dimensions for finding\n   * the closest handle to user interaction\n   * @return {object} the range slider DOM client rect\n   **/\n  function getSliderDimensions() {\n    return slider.getBoundingClientRect();\n  }\n\n  /**\n   * helper to return closest handle to user interaction\n   * @param {object} clientPos the client{x,y} positions to check against\n   * @return {number} the index of the closest handle to clientPos\n   **/\n  function getClosestHandle(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let hPos = 0;\n    let hPercent = 0;\n    let hVal = 0;\n    if (vertical) {\n      hPos = clientPos.clientY - dims.top;\n      hPercent = (hPos / dims.height) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    } else {\n      hPos = clientPos.clientX - dims.left;\n      hPercent = (hPos / dims.width) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    }\n\n    let closest;\n\n    // if we have a range, and the handles are at the same\n    // position, we want a simple check if the interaction\n    // value is greater than return the second handle\n    if (range === true && values[0] === values[1]) {\n      if (hVal > values[1]) {\n        return 1;\n      } else {\n        return 0;\n      }\n      // if there are multiple handles, and not a range, then\n      // we sort the handles values, and return the first one closest\n      // to the interaction value\n    } else {\n      closest = values.indexOf(\n        [...values].sort((a, b) => Math.abs(hVal - a) - Math.abs(hVal - b))[0]\n      );\n    }\n    return closest;\n  }\n\n  /**\n   * take the interaction position on the slider, convert\n   * it to a value on the range, and then send that value\n   * through to the moveHandle() method to set the active\n   * handle's position\n   * @param {object} clientPos the client{x,y} of the interaction\n   **/\n  function handleInteract(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let hPos = 0;\n    let hPercent = 0;\n    let hVal = 0;\n    if (vertical) {\n      hPos = clientPos.clientY - dims.top;\n      hPercent = (hPos / dims.height) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    } else {\n      hPos = clientPos.clientX - dims.left;\n      hPercent = (hPos / dims.width) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    }\n    // move handle to the value\n    moveHandle(activeHandle, hVal);\n  }\n\n  /**\n   * move a handle to a specific value, respecting the clamp/align rules\n   * @param {number} index the index of the handle we want to move\n   * @param {number} value the value to move the handle to\n   * @return {number} the value that was moved to (after alignment/clamping)\n   **/\n  function moveHandle(index, value) {\n    // align & clamp the value so we're not doing extra\n    // calculation on an out-of-range value down below\n    value = alignValueToStep(value);\n    // if this is a range slider\n    if (range) {\n      // restrict the handles of a range-slider from\n      // going past one-another unless \"pushy\" is true\n      if (index === 0 && value > values[1]) {\n        if (pushy) {\n          values[1] = value;\n        } else {\n          value = values[1];\n        }\n      } else if (index === 1 && value < values[0]) {\n        if (pushy) {\n          values[0] = value;\n        } else {\n          value = values[0];\n        }\n      }\n    }\n\n    // if the value has changed, update it\n    if (values[index] !== value) {\n      values[index] = value;\n    }\n\n    // fire the change event when the handle moves,\n    // and store the previous value for the next time\n    if (previousValue !== value) {\n      eChange();\n      previousValue = value;\n    }\n  }\n\n  /**\n   * helper to find the beginning range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the beginning of the range\n   **/\n  function rangeStart(values) {\n    if (range === \"min\") {\n      return 0;\n    } else {\n      return values[0];\n    }\n  }\n\n  /**\n   * helper to find the ending range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the end of the range\n   **/\n  function rangeEnd(values) {\n    if (range === \"max\") {\n      return 0;\n    } else if (range === \"min\") {\n      return 100 - values[0];\n    } else {\n      return 100 - values[1];\n    }\n  }\n\n  /**\n   * when the user has unfocussed (blurred) from the\n   * slider, deactivated all handles\n   * @param {event} e the event from browser\n   **/\n  function sliderBlurHandle(e) {\n    if (keyboardActive) {\n      focus = false;\n      handleActivated = false;\n      handlePressed = false;\n    }\n  }\n\n  /**\n   * when the user focusses the handle of a slider\n   * set it to be active\n   * @param {event} e the event from browser\n   **/\n  function sliderFocusHandle(e) {\n    if ( !disabled ) {\n      activeHandle = index(e.target);\n      focus = true;\n    }\n  }\n\n  /**\n   * handle the keyboard accessible features by checking the\n   * input type, and modfier key then moving handle by appropriate amount\n   * @param {event} e the event from browser\n   **/\n  function sliderKeydown(e) {\n    if ( !disabled ) {\n      const handle = index(e.target);\n      let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;\n      let prevent = false;\n\n      switch (e.key) {\n        case \"PageDown\":\n          jump *= 10;\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n          moveHandle(handle, values[handle] + jump);\n          prevent = true;\n          break;\n        case \"PageUp\":\n          jump *= 10;\n        case \"ArrowLeft\":\n        case \"ArrowDown\":\n          moveHandle(handle, values[handle] - jump);\n          prevent = true;\n          break;\n        case \"Home\":\n          moveHandle(handle, min);\n          prevent = true;\n          break;\n        case \"End\":\n          moveHandle(handle, max);\n          prevent = true;\n          break;\n      }\n      if (prevent) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }\n\n  /**\n   * function to run when the user touches\n   * down on the slider element anywhere\n   * @param {event} e the event from browser\n   **/\n  function sliderInteractStart(e) {\n    if ( !disabled ) {\n      const clientPos = normalisedClient(e);\n      // set the closest handle as active\n      focus = true;\n      handleActivated = true;\n      handlePressed = true;\n      activeHandle = getClosestHandle(clientPos);\n\n      // fire the start event\n      startValue = previousValue = alignValueToStep(values[activeHandle]);\n      eStart();\n\n      // for touch devices we want the handle to instantly\n      // move to the position touched for more responsive feeling\n      if (e.type === \"touchstart\") {\n        handleInteract(clientPos);\n      }\n    }\n  }\n\n  /**\n   * function to run when the user stops touching\n   * down on the slider element anywhere\n   * @param {event} e the event from browser\n   **/\n  function sliderInteractEnd(e) {\n    // fire the stop event for touch devices\n    if (e.type === \"touchend\") {\n      eStop();\n    }\n    handlePressed = false;\n  }\n\n  /**\n   * unfocus the slider if the user clicked off of\n   * it, somewhere else on the screen\n   * @param {event} e the event from browser\n   **/\n  function bodyInteractStart(e) {\n    keyboardActive = false;\n    if (focus && e.target !== slider && !slider.contains(e.target)) {\n      focus = false;\n    }\n  }\n\n  /**\n   * send the clientX through to handle the interaction\n   * whenever the user moves acros screen while active\n   * @param {event} e the event from browser\n   **/\n  function bodyInteract(e) {\n    if ( !disabled ) {\n      if (handleActivated) {\n        handleInteract(normalisedClient(e));\n      }\n    }\n  }\n\n  /**\n   * if user triggers mouseup on the body while\n   * a handle is active (without moving) then we\n   * trigger an interact event there\n   * @param {event} e the event from browser\n   **/\n  function bodyMouseUp(e) {\n    if ( !disabled ) {\n      const el = e.target;\n      // this only works if a handle is active, which can\n      // only happen if there was sliderInteractStart triggered\n      // on the slider, already\n      if (handleActivated) {\n        if (el === slider || slider.contains(el)) {\n          focus = true;\n          if (!targetIsHandle(el)) {\n            handleInteract(normalisedClient(e));\n          }\n        }\n        // fire the stop event for mouse device\n        // when the body is triggered with an active handle\n        eStop();\n      }\n    }\n    handleActivated = false;\n    handlePressed = false;\n  }\n\n  /**\n   * if user triggers touchend on the body then we\n   * defocus the slider completely\n   * @param {event} e the event from browser\n   **/\n  function bodyTouchEnd(e) {\n    handleActivated = false;\n    handlePressed = false;\n  }\n\n  function bodyKeyDown(e) {\n    if ( !disabled ) {\n      if (e.target === slider || slider.contains(e.target)) {\n        keyboardActive = true;\n      }\n    }\n  }\n\n  function eStart() {\n    !disabled && dispatch(\"start\", {\n      activeHandle,\n      value: startValue,\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n\n  function eStop() {\n    !disabled && dispatch(\"stop\", {\n      activeHandle,\n      startValue: startValue,\n      value: values[activeHandle],\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n\n  function eChange() {\n    !disabled && dispatch(\"change\", {\n      activeHandle,\n      startValue: startValue,\n      previousValue:\n        typeof previousValue === \"undefined\" ? startValue : previousValue,\n      value: values[activeHandle],\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --slider: var(--range-slider, #d7dada);\n    --handle-inactive: var(--range-handle-inactive, #99a2a2);\n    --handle: var(--range-handle, #838de7);\n    --handle-focus: var(--range-handle-focus, #4a40d4);\n    --handle-border: var(--range-handle-border, var(--handle));\n    --range-inactive: var(--range-range-inactive, var(--handle-inactive));\n    --range: var(--range-range, var(--handle-focus));\n    --float-inactive: var(--range-float-inactive, var(--handle-inactive));\n    --float: var(--range-float, var(--handle-focus));\n    --float-text: var(--range-float-text, white);\n  }\n  :global(.rangeSlider) {\n    position: relative;\n    border-radius: 100px;\n    height: 0.5em;\n    margin: 1em;\n    transition: opacity 0.2s ease;\n  }\n  :global(.rangeSlider, .rangeSlider *) {\n    user-select: none;\n  }\n  :global(.rangeSlider.pips) {\n    margin-bottom: 1.8em;\n  }\n  :global(.rangeSlider.pip-labels) {\n    margin-bottom: 2.8em;\n  }\n  :global(.rangeSlider.vertical) {\n    display: inline-block;\n    border-radius: 100px;\n    width: 0.5em;\n    min-height: 200px;\n  }\n  :global(.rangeSlider.vertical.pips) {\n    margin-right: 1.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider.vertical.pip-labels) {\n    margin-right: 2.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider .rangeHandle) {\n    position: absolute;\n    display: block;\n    height: 1.4em;\n    width: 1.4em;\n    top: 0.25em;\n    left: 0.25em;\n    transform: translateY(-50%) translateX(-50%);\n    z-index: 2;\n  }\n  :global(.rangeSlider .rangeNub),\n  :global(.rangeSlider .rangeHandle:before) {\n    position: absolute;\n    left: 0;\n    top: 0;\n    display: block;\n    border-radius: 10em;\n    height: 100%;\n    width: 100%;\n    transition: all 0.2s ease;\n  }\n  :global(.rangeSlider .rangeHandle:before) {\n    content: \"\";\n    left: 1px;\n    top: 1px;\n    bottom: 1px;\n    right: 1px;\n    height: auto;\n    width: auto;\n    box-shadow: 0 0 0 0px var(--handle-border);\n    opacity: 0;\n  }\n  :global(.rangeSlider .rangeHandle.hoverable:hover:before) {\n    box-shadow: 0 0 0 8px var(--handle-border);\n    opacity: 0.2;\n  }\n  :global(.rangeSlider .rangeHandle.hoverable.press:before),\n  :global(.rangeSlider .rangeHandle.hoverable.press:hover:before) {\n    box-shadow: 0 0 0 12px var(--handle-border);\n    opacity: 0.4;\n  }\n  :global(.rangeSlider.range:not(.min):not(.max) .rangeNub) {\n    border-radius: 10em 10em 10em 1.6em;\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-135deg);\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(45deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-45deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(135deg);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    display: block;\n    position: absolute;\n    left: 50%;\n    top: -0.5em;\n    transform: translate(-50%, -100%);\n    font-size: 1em;\n    text-align: center;\n    opacity: 0;\n    pointer-events: none;\n    white-space: nowrap;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n    padding: 0.2em 0.4em;\n    border-radius: 0.2em;\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeFloat),\n  :global(.rangeSlider .rangeHandle.hoverable:hover .rangeFloat) {\n    opacity: 1;\n    top: -0.2em;\n    transform: translate(-50%, -100%);\n  }\n  :global(.rangeSlider .rangeBar) {\n    position: absolute;\n    display: block;\n    transition: background 0.2s ease;\n    border-radius: 1em;\n    height: 0.5em;\n    top: 0;\n    user-select: none;\n    z-index: 1;\n  }\n  :global(.rangeSlider.vertical .rangeBar) {\n    width: 0.5em;\n    height: auto;\n  }\n  :global(.rangeSlider) {\n    background-color: #d7dada;\n    background-color: var(--slider);\n  }\n  :global(.rangeSlider .rangeBar) {\n    background-color: #99a2a2;\n    background-color: var(--range-inactive);\n  }\n  :global(.rangeSlider.focus .rangeBar) {\n    background-color: #838de7;\n    background-color: var(--range);\n  }\n  :global(.rangeSlider .rangeNub) {\n    background-color: #99a2a2;\n    background-color: var(--handle-inactive);\n  }\n  :global(.rangeSlider.focus .rangeNub) {\n    background-color: #838de7;\n    background-color: var(--handle);\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeNub) {\n    background-color: #4a40d4;\n    background-color: var(--handle-focus);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    color: white;\n    color: var(--float-text);\n    background-color: #99a2a2;\n    background-color: var(--float-inactive);\n  }\n  :global(.rangeSlider.focus .rangeFloat) {\n    background-color: #4a40d4;\n    background-color: var(--float);\n  }\n  :global(.rangeSlider.disabled ) {\n    opacity: 0.5;\n  }\n  :global(.rangeSlider.disabled .rangeNub) {\n    background-color: #d7dada;\n    background-color: var(--slider);\n  }\n</style>\n\n<div\n  {id}\n  bind:this={slider}\n  class=\"rangeSlider\"\n  class:range\n  class:disabled\n  class:vertical\n  class:focus\n  class:min={range === 'min'}\n  class:max={range === 'max'}\n  class:pips\n  class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}\n  on:mousedown={sliderInteractStart}\n  on:mouseup={sliderInteractEnd}\n  on:touchstart|preventDefault={sliderInteractStart}\n  on:touchend|preventDefault={sliderInteractEnd}\n>\n  {#each values as value, index}\n    <span\n      role=\"slider\"\n      class=\"rangeHandle\"\n      class:hoverable={hover && !disabled}\n      class:active={focus && activeHandle === index}\n      class:press={handlePressed && activeHandle === index}\n      on:blur={sliderBlurHandle}\n      on:focus={sliderFocusHandle}\n      on:keydown={sliderKeydown}\n      style=\"{vertical ? 'top' : 'left'}: {$springPositions[index]}%; z-index: {activeHandle === index ? 3 : 2};\"\n      aria-valuemin={range === true && index === 1 ? values[0] : min}\n      aria-valuemax={range === true && index === 0 ? values[1] : max}\n      aria-valuenow={value}\n      aria-valuetext=\"{prefix}{handleFormatter(value)}{suffix}\"\n      aria-orientation={vertical ? 'vertical' : 'horizontal'}\n      aria-disabled={disabled}\n      {disabled}\n      tabindex=\"{ disabled ? -1 : 0 }\"\n    >\n      <span class=\"rangeNub\" />\n      {#if float}\n        <span class=\"rangeFloat\">{prefix}{handleFormatter(value)}{suffix}</span>\n      {/if}\n    </span>\n  {/each}\n  {#if range}\n    <span\n      class=\"rangeBar\"\n      style=\"{vertical ? 'top' : 'left'}: {rangeStart($springPositions)}%; {vertical ? 'bottom' : 'right'}:\n      {rangeEnd($springPositions)}%;\" />\n  {/if}\n  {#if pips}\n    <RangePips\n      {values}\n      {min}\n      {max}\n      {step}\n      {range}\n      {vertical}\n      {all}\n      {first}\n      {last}\n      {rest}\n      {pipstep}\n      {prefix}\n      {suffix}\n      {formatter}\n      {focus}\n      {disabled}\n      {percentOf} />\n  {/if}\n</div>\n\n<svelte:window\n  on:mousedown={bodyInteractStart}\n  on:touchstart={bodyInteractStart}\n  on:mousemove={bodyInteract}\n  on:touchmove={bodyInteract}\n  on:mouseup={bodyMouseUp}\n  on:touchend={bodyTouchEnd}\n  on:keydown={bodyKeyDown} />\n",
    "<script lang=\"ts\">;\r\n;\r\nimport { slope, twoPointForm } from \"./graphablefunctions\";\r\nimport { range, sumBy } from \"./helpers\";\r\nimport { visitStrategy } from \"./rectangles\";\r\nimport RangeSlider from \"svelte-range-slider-pips\";\r\nimport * as katex from \"katex\";\r\nimport Katex from \"./Katex.svelte\";\r\nimport { onMount } from 'svelte/internal';\r\nimport { tooltip } from './tooltip';\r\n// ********************* graph *********************\r\nconst DEFAULT_BOUND_MAGNITUDE = Math.ceil(Math.PI);\r\nconst GRAPH_AXIS_MARK_LENGTH = 0.08;\r\nconst xMaxBound = DEFAULT_BOUND_MAGNITUDE;\r\nconst xMinBound = -DEFAULT_BOUND_MAGNITUDE;\r\nconst yMaxBound = DEFAULT_BOUND_MAGNITUDE;\r\nconst yMinBound = -DEFAULT_BOUND_MAGNITUDE;\r\n// ********************* function *********************\r\nlet f;\r\n$: f = functions[selectedFunctionIndex].implementation;\r\nlet numberOfPoints = 100;\r\nlet points;\r\n$: points = [...range(numberOfPoints).map(n => {\r\n        const x = xMinBound + (n * ((xMaxBound - xMinBound) / numberOfPoints));\r\n        return { x: x, y: f(x) };\r\n    }), { x: xMaxBound, y: f(xMaxBound) }];\r\n// ********************* derivatives *********************\r\n// Aproximation of delta x -> 0\r\nconst DELTA_X_APPROACHES_0 = 0.00000001;\r\n// Delta x\r\nlet deltaXSliderFromRight = [1];\r\nlet deltaXSliderFromLeft = [-1];\r\n$: deltaX = (derivativeLimitStrategy === 'FromRight') ? deltaXSliderFromRight[0] : deltaXSliderFromLeft[0];\r\n// User input into the fucntion x\r\nlet xSlider = [1];\r\nlet x;\r\n$: x = xSlider[0];\r\n// Wheather delta x -> 0 from the left or the right \r\nlet derivativeLimitStrategy = 'FromRight';\r\n// Points of tangnet line\r\nlet secantPoint1;\r\n$: secantPoint1 = { x: x, y: f(x) };\r\nlet secantPoint2;\r\n$: secantPoint2 = (deltaX !== 0) ? { x: x + deltaX, y: f(x + deltaX) } : tangentPoint2;\r\n// Points of secant line\r\nlet tangentPoint1;\r\n$: tangentPoint1 = { x: x, y: f(x) };\r\nlet tangentPoint2;\r\n$: tangentPoint2 = { x: x + DELTA_X_APPROACHES_0, y: f(x + DELTA_X_APPROACHES_0) };\r\n// Function for secant line\r\nlet secant;\r\n$: secant = twoPointForm(secantPoint1, secantPoint2);\r\n// Slope of the secant\r\nlet slopeSecant;\r\n$: slopeSecant = (deltaX !== 0) ? slope(secantPoint1, secantPoint2) : slopeTangent;\r\n// Display of seecant lane \r\nlet secantLine;\r\n$: secantLine = {\r\n    x1: xMinBound, y1: secant(xMinBound),\r\n    x2: xMaxBound, y2: secant(xMaxBound)\r\n};\r\n// Function for tangnet line\r\nlet tangent;\r\n$: tangent = twoPointForm(tangentPoint1, tangentPoint2);\r\n// Slope of tangnet\r\nlet slopeTangent;\r\n$: slopeTangent = slope(tangentPoint1, tangentPoint2);\r\nlet tangentLine;\r\n$: tangentLine = {\r\n    x1: xMinBound, y1: tangent(xMinBound),\r\n    x2: xMaxBound, y2: tangent(xMaxBound)\r\n};\r\n// $: derivativeDef = `\\\\dfrac{\\\\mathrm{d}}{\\\\mathrm{d}x} ${(deltaX !== 0) ? `{\\\\color{crimson}\\\\:\\\\approx}` : `=`} \r\n// \t{\\\\color{${(deltaX !== 0) ? `lightgray` : `crimson`}}\r\n// \t\\\\lim_{\\\\Delta x \\\\rightarrow 0}} \\\\frac{f(x + \\\\Delta x) - f(x)}{\\\\Delta x} \r\n// \t= ${slopeSecant.toFixed(2).replace('-0.00', '0.00')}`;\r\n$: derivativeDef = `\\\\dfrac{\\\\mathrm{d}}{\\\\mathrm{d}x} f(x)\r\n\t\t${(deltaX !== 0) ? `{\\\\color{crimson}\\\\:\\\\approx}` : `{\\\\color{crimson}\\\\:=}`} \r\n\t\t{\\\\color{${(deltaX !== 0) ? `lightgray` : `crimson`}} \\\\lim_{\\\\Delta x \\\\rightarrow 0}} \r\n\t\t\\\\frac{f(x + \\\\Delta x) - f(x)}{\\\\Delta x} \r\n\t\t= ${slopeSecant.toFixed(2).replace('-0.00', '0.00')}`;\r\n// ********************* integrals *********************\r\n// Maximum user input of the slider before the user makes n -> infinity\r\nconst MAX_INPUT_RECTANGLES = 150;\r\n// Number of rectangles used to display integral when n approches infinity  \r\nconst DISPLAY_N_APPROCHES_INFINITY = 1000;\r\n// Bounds of the integral \r\nlet integralBoundsInput = [-DEFAULT_BOUND_MAGNITUDE, DEFAULT_BOUND_MAGNITUDE];\r\n$: integralLowerBound = integralBoundsInput[0];\r\n$: integralUpperBound = integralBoundsInput[1];\r\n// Type of Riemann integral \r\nlet rectangleStrategy;\r\n$: rectangleStrategy = 'Left';\r\n// Weather integral is approximate or note. AKA \"n approches infinity\"\r\nlet nApprochesInfinity = false;\r\n$: nApprochesInfinity = (numberRectanglesInput[0] === MAX_INPUT_RECTANGLES + 1);\r\n// Number of rectangles in the Riemann integral \r\nlet numberRectanglesInput = [5];\r\n$: numberRectangles = (nApprochesInfinity) ? DISPLAY_N_APPROCHES_INFINITY : numberRectanglesInput[0];\r\n// Width of each rectangle\r\nlet rectangleWidth;\r\n$: rectangleWidth = Math.abs((integralUpperBound - integralLowerBound) / numberRectangles); //sliderRectangleWidth//Math.exp(sliderRectangleWidth) - 1;\r\n// Riemann rectangles\r\nlet riemannRectangles;\r\n$: riemannRectangles = range(numberRectangles).map(n => {\r\n    const x = integralLowerBound + (n * (integralUpperBound - integralLowerBound) / numberRectangles);\r\n    const y = f(x + visitStrategy(rectangleStrategy, {\r\n        Left: 0,\r\n        Midpoint: (rectangleWidth / 2),\r\n        Right: rectangleWidth\r\n    }));\r\n    // SVG can't process negative height \r\n    return {\r\n        height: Math.abs(y),\r\n        width: rectangleWidth,\r\n        lowerLeftCorner: { x: x, y: (y > 0) ? 0 : y }\r\n    };\r\n});\r\n// Sum of all rectangles \r\nlet riemannSum;\r\n$: riemannSum = sumBy(riemannRectangles, rectangle => (rectangle.lowerLeftCorner.y === 0) ?\r\n    rectangle.width * rectangle.height :\r\n    -rectangle.width * rectangle.height);\r\n// Real value of the integral when n -> infinity\r\n$: integralValue = functions[selectedFunctionIndex].integral(integralUpperBound)\r\n    - functions[selectedFunctionIndex].integral(integralLowerBound);\r\n// Location of the labels for the upper and lower bounds\r\nlet boundLabelPostion;\r\n$: boundLabelPostion = (() => {\r\n    if (integralUpperBound === xMaxBound && integralLowerBound === xMaxBound)\r\n        return integralUpperBound - 0.4;\r\n    else if (integralUpperBound === xMinBound && integralLowerBound === xMinBound)\r\n        return integralUpperBound;\r\n    else\r\n        return integralUpperBound - 0.15;\r\n})();\r\n// Displayed approximation or definition of an integral, depending on whether n approaches infinity \r\n$: integralDef = `\\\\int_{a}^{b} f(x)dx ${(!nApprochesInfinity) ? `{\\\\color{crimson}\\\\:\\\\approx}` : `{\\\\color{crimson}\\\\:=}`} \r\n\t\t{\\\\color{${(!nApprochesInfinity) ? `lightgray` : `crimson`}} \r\n\t\t\\\\lim_{n \\\\rightarrow \\\\infty}} \\\\sum_{i=1}^n f(x_i)\\\\Delta x\r\n\t\t= ${((!nApprochesInfinity) ? riemannSum : integralValue).toFixed(2).replace('-0.00', '0.00')}`;\r\nlet context;\r\n$: context = \"Derivative\";\r\n// $: context = \"Integral\"\r\n// $: context = \"About\"\r\nlet selectedFunctionIndex = 0;\r\nconst functions = [\r\n    {\r\n        id: 'sine',\r\n        implementation: (x) => Math.sin(x),\r\n        integral: (x) => -Math.cos(x),\r\n        representation: 'f(x) = \\\\sin(x)'\r\n    },\r\n    {\r\n        id: 'quadratic',\r\n        implementation: (x) => x * x,\r\n        integral: (x) => Math.pow(x, 3) / 3,\r\n        representation: 'f(x) = x^2'\r\n    },\r\n    {\r\n        id: 'exponential',\r\n        implementation: (x) => Math.exp(x),\r\n        integral: (x) => Math.exp(x),\r\n        representation: 'f(x) = e^x'\r\n    },\r\n    {\r\n        id: 'cubic',\r\n        implementation: (x) => (x - 1) * (x) * (x + 1),\r\n        integral: (x) => (Math.pow(x, 2) * (Math.pow(x, 2) - 2)) / 4,\r\n        representation: 'f(x) = (x - 1)(x)(x + 1)'\r\n    },\r\n];\r\n// ********************* equation rendering *********************\r\n// onMount(() => {\r\n// \t// functions at the top\r\n// \tfor (let f of functions) {\r\n// \t\tkatex.render(f.representation, document.getElementById(`${f.id}`), {output: 'html'});\r\n// \t}\r\n// \t//renderEquation()\r\n// });\r\nfunction renderEquation() {\r\n    // katex.render(`x = ${x}`, document.getElementById('xEquals'))\r\n    // katex.render(`\\\\Delta x = ${deltaX}`, document.getElementById('deltaXEquals'))\r\n    // katex.render('m = \\\\lim_{\\\\Delta x \\\\rightarrow 0} \\\\frac{f(x + \\\\Delta x) - f(x)}{\\\\Delta x}',\r\n    // \tdocument.getElementById('differenceEquation1'), {output: 'html'})\r\n    // katex.render(`m = \\\\frac{f(x + ${g(deltaX)}) - f(x)}{${g(deltaX)}}`,\r\n    // \tdocument.getElementById('differenceEquation2'), {output: 'html'})\r\n    // katex.render(`m = \\\\frac{f(${g(x)} + ${g(deltaX)}) - f(${g(x)})}{${g(deltaX)}}`,\r\n    // \tdocument.getElementById('differenceEquation3'), {output: 'html'})\r\n    // katex.render(`m = \\\\frac{f(${g(x + deltaX)}) - f(${g(x)})}{${g(deltaX)}}`,\r\n    // \tdocument.getElementById('differenceEquation4'), {output: 'html'})\r\n    // katex.render(`m = ${g(f(x + deltaX) - f(x) / deltaX)}`,\r\n    // \tdocument.getElementById('differenceEquation5'), {output: 'html'})\r\n}\r\nfunction g(n) {\r\n    return n.toFixed(2);\r\n}\r\n</script>\r\n<div class=\"outer\">\r\n<div class=\"container\">\r\n\t<p>\r\n\t\t<button class={context === 'Derivative' ? 'highlighted' : ''}  on:click={_ => context = 'Derivative'}>Derivatives</button>\r\n\t\t<button class={context === 'Integral' ? 'highlighted' : ''}  on:click={_ => context = 'Integral'}>Integral</button>\r\n\t\t| <button class={context === 'About' ? 'highlighted' : ''}  on:click={_ => context = 'About'}>About</button>\r\n\t\t\r\n\t</p>\r\n\t{#if context !== 'About'}\r\n\t\t{#each functions as f, functionIndex}\r\n\t\t\t<button class={functionIndex === selectedFunctionIndex ? 'highlighted' : ''} on:click={() => selectedFunctionIndex = functionIndex}>\r\n\t\t\t\t<Katex math={f.representation}/>\r\n\t\t\t</button>\r\n\t\t{/each}\r\n\t\t\r\n\t\t<!-- derivatives -->\r\n\t\t<svg class=\"cartesian\" viewBox=\"{xMinBound} {yMinBound} {(xMaxBound - xMinBound)} {(yMaxBound - yMinBound)}\">\r\n\t\t\t<g>\r\n\t\t\t\t{#if context === 'Derivative'}\r\n\t\t\t\t\t\r\n\t\t\t\t\t<line stroke=\"crimson\" stroke-dasharray=\"4,4\" fill=\"none\"\r\n\t\t\t\t\t\tx1={secantLine.x1} y1={secantLine.y1}\r\n\t\t\t\t\t\tx2={secantLine.x2} y2={secantLine.y2}\r\n\t\t\t\t\t/>\r\n\r\n\t\t\t\t\t<!-- <line stroke=\"grey\" stroke-dasharray=\"4,4\" fill=\"none\"\r\n\t\t\t\t\t\tx1={tangentLine.x1} y1={tangentLine.y1}\r\n\t\t\t\t\t\tx2={tangentLine.x2} y2={tangentLine.y2}\r\n\t\t\t\t\t\tvisibility={(deltaX !== 0) ? \"visible\" : \"hidden\"}\r\n\t\t\t\t\t/> -->\r\n\r\n\t\t\t\t\t<circle use:tooltip data-title={`(${x.toFixed(2)}, ${f(x).toFixed(2)})`} cx={x} cy={f(x)} r=\".075\" fill=\"crimson\"></circle>\r\n\t\t\t\t\t<circle use:tooltip data-title={`(${(x + deltaX).toFixed(2)}, ${f(x + deltaX).toFixed(2)})`} cx={x + deltaX} cy={f(x + deltaX)} r=\".075\" fill=\"crimson\"></circle>\r\n\t\t\t\r\n\t\t\t\t\t<!-- why does the y value need to be negative?-->\r\n\t\t\t\t\t<!-- <text x={x + deltaX + 0.5} y={-secant(x + deltaX)} font-size=\".4\">m={slope(secantPoint1, secantPoint2).toFixed(2)}</text> -->\r\n\t\t\t\t{:else}\r\n\t\t\t\t\t<!-- bounds of integral -->\r\n\t\t\t\t\t<line stroke=\"black\" stroke-dasharray=\"2,2\" fill=\"none\" x1={integralLowerBound} y1={yMinBound + 0.3} x2={integralLowerBound} y2={yMaxBound} />\r\n\t\t\t\t\t<text class=\"integeralBound\" x={integralLowerBound} y={-yMinBound - 0.04}>{(integralLowerBound !== integralUpperBound) ? 'a' : ''}</text>\r\n\t\t\r\n\t\t\t\t\t<line stroke=\"black\" stroke-dasharray=\"2,2\" fill=\"none\" x1={integralUpperBound} y1={yMinBound + 0.3} x2={integralUpperBound} y2={yMaxBound} />\r\n\t\t\t\t\t<text class=\"integeralBound\" x={boundLabelPostion} y={-yMinBound - 0.04}>\r\n\t\t\t\t\t\t{(integralLowerBound !== integralUpperBound) ? 'b' : 'a, b'}\r\n\t\t\t\t\t</text>\r\n\r\n\t\t\t\t\t{#each riemannRectangles as rectangle}\r\n\t\t\t\t\t\t<rect\r\n\t\t\t\t\t\t\tclass={(rectangleWidth > 0.1) ? \"riemann-rectangle\" : \"riemann-rectangle-no-stroke\"}\r\n\t\t\t\t\t\t\tx={rectangle.lowerLeftCorner.x}\r\n\t\t\t\t\t\t\ty={rectangle.lowerLeftCorner.y}\r\n\t\t\t\t\t\t\twidth={rectangle.width}\r\n\t\t\t\t\t\t\theight={rectangle.height}\r\n\t\t\t\t\t\t/>\r\n\t\t\t\t\t{/each}\r\n\r\n\r\n\t\t\t\t\r\n\t\t\t\t{/if}\r\n\t\t\t\t<!-- x and y axis -->\r\n\t\t\t\t<text class=\"AxisLabel\" x={xMaxBound - 0.30} y={0.25}>+x</text>\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={xMinBound} y1=\"0\" x2={xMaxBound} y2=\"0\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"1\"  y1={GRAPH_AXIS_MARK_LENGTH} x2=\"1\"  y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"2\"  y1={GRAPH_AXIS_MARK_LENGTH} x2=\"2\"  y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"3\"  y1={GRAPH_AXIS_MARK_LENGTH} x2=\"3\"  y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"4\"  y1={GRAPH_AXIS_MARK_LENGTH} x2=\"4\"  y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"-1\" y1={GRAPH_AXIS_MARK_LENGTH} x2=\"-1\" y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"-2\" y1={GRAPH_AXIS_MARK_LENGTH} x2=\"-2\" y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"-3\" y1={GRAPH_AXIS_MARK_LENGTH} x2=\"-3\" y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"-4\" y1={GRAPH_AXIS_MARK_LENGTH} x2=\"-4\" y2={-GRAPH_AXIS_MARK_LENGTH} />\r\n\t\t\t\t<text class=\"AxisLabel\" x={0.1} y={yMinBound + 0.2}>+y</text>\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1=\"0\" y1={yMinBound} x2=\"0\" y2={yMaxBound} />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"1\"  x2={GRAPH_AXIS_MARK_LENGTH} y2=\"1\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"2\"  x2={GRAPH_AXIS_MARK_LENGTH} y2=\"2\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"3\"  x2={GRAPH_AXIS_MARK_LENGTH} y2=\"3\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"4\"  x2={GRAPH_AXIS_MARK_LENGTH} y2=\"4\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"-1\" x2={GRAPH_AXIS_MARK_LENGTH} y2=\"-1\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"-2\" x2={GRAPH_AXIS_MARK_LENGTH} y2=\"-2\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"-3\" x2={GRAPH_AXIS_MARK_LENGTH} y2=\"-3\" />\r\n\t\t\t\t<line stroke=\"black\" fill=\"none\" x1={-GRAPH_AXIS_MARK_LENGTH} y1=\"-4\" x2={GRAPH_AXIS_MARK_LENGTH} y2=\"-4\" />\r\n\t\t\t\t<!-- graph of function -->\r\n\t\t\t\t<polyline stroke=\"black\" fill=\"none\" points={points.map(point => `${point.x},${point.y}`).join(' ')} />\r\n\t\t\t</g>\r\n\t\t</svg>\r\n\r\n\t\t<span class='equation'>\r\n\t\t\t{#if context === 'Derivative'}\r\n\t\t\t\t<Katex math={derivativeDef} displayMode/>\r\n\t\t\t{:else}\r\n\t\t\t\t<Katex math={integralDef} displayMode/>\r\n\t\t\t{/if}\r\n\t\t</span>\r\n\r\n\t\t{#if context === 'Derivative'}\r\n\t\t\t<label for=\"deltaX\">\r\n\t\t\t\t<Katex math={`\\\\Delta x :`}></Katex> {deltaX.toFixed(2)}\r\n\t\t\t</label>\r\n\r\n\t\t\t<span id=\"deltaXInput\" class=\"slider\">\r\n\t\t\t\t{#if derivativeLimitStrategy === 'FromRight'}\r\n\t\t\t\t\t<RangeSlider \r\n\t\t\t\t\tstep={0.01} \r\n\t\t\t\t\tbind:values={deltaXSliderFromRight}\t\t\r\n\t\t\t\t\trange={false}\r\n\t\t\t\t\tmin={0}\r\n\t\t\t\t\tmax={1}\r\n\t\t\t\t\tpips\r\n\t\t\t\t\tfirst={'label'} \r\n\t\t\t\t\tlast={'label'}\r\n\t\t\t\t\trest={false}\r\n\t\t\t\t\tspringValues={{stiffness: 1, damping: 1 }}\r\n\t\t\t\t\t/>\r\n\t\t\t\t{:else}\r\n\t\t\t\t\t<RangeSlider \r\n\t\t\t\t\tstep={0.01} \r\n\t\t\t\t\tbind:values={deltaXSliderFromLeft}\t\t\r\n\t\t\t\t\trange={false}\r\n\t\t\t\t\tmin={-1}\r\n\t\t\t\t\tmax={0}\r\n\t\t\t\t\tpips\r\n\t\t\t\t\tfirst={'label'} \r\n\t\t\t\t\tlast={'label'}\r\n\t\t\t\t\trest={false}\r\n\t\t\t\t\tspringValues={{stiffness: 1, damping: 1 }}\r\n\t\t\t\t\t/>\r\n\t\t\t\t{/if}\r\n\t\t\t\t\r\n\t\t\t</span>\r\n\t\t\t\r\n\t\t\t<label for=\"xSliderInput\"><Katex math={`x :`}></Katex> {x.toFixed(2)}</label>\r\n\t\t\t<span id=\"xSliderInput\" class=\"slider\">\r\n\t\t\t\t<RangeSlider  \r\n\t\t\t\tmin={xMinBound} \r\n\t\t\t\tmax={xMaxBound}\r\n\t\t\t\tstep={0.01} \r\n\t\t\t\tbind:values={xSlider}\t\t\r\n\t\t\t\trange={false}\r\n\t\t\t\tpips\r\n\t\t\t\tfirst={'label'} \r\n\t\t\t\tlast={'label'}\r\n\t\t\t\trest={false}\r\n\t\t\t\tspringValues={{stiffness: 1, damping: 1 }}\r\n\t\t\t\t/>\r\n\t\t\t</span>\r\n\r\n\t\t\t<button class={derivativeLimitStrategy === 'FromLeft' ? 'highlighted' : ''}  on:click={_ => derivativeLimitStrategy = 'FromLeft'}>Limit from left</button>\r\n\t\t\t<button class={derivativeLimitStrategy === 'FromRight' ? 'highlighted' : ''}  on:click={_ => derivativeLimitStrategy = 'FromRight'}>Limit from right</button>\r\n\t\t{:else}\r\n\t\t\t<label id=\"NumberRectangles\" for=\"RectangleWidthValue\"><Katex math={`n :`}></Katex> {(nApprochesInfinity) ? `∞` : numberRectangles}</label>\r\n\t\t\t<span class=\"slider\">\r\n\t\t\t\t<RangeSlider \r\n\t\t\t\t\tmin={1} \r\n\t\t\t\t\tmax={MAX_INPUT_RECTANGLES + 1} \r\n\t\t\t\t\tpips \r\n\t\t\t\t\tall='label' \r\n\t\t\t\t\tbind:values={numberRectanglesInput}\r\n\t\t\t\t\tpipstep={20}\t\r\n\t\t\t\t\tformatter={value => (value === MAX_INPUT_RECTANGLES + 1) ? '∞' : value}\t\r\n\t\t\t\t\tfloat \r\n\t\t\t\t\thover\r\n\t\t\t\t\tspringValues={{stiffness: 1, damping: 1 }}\r\n\t\t\t\t/>\r\n\t\t\t</span>\r\n\r\n\t\t\t<span class=\"slider\">\r\n\t\t\t\t<RangeSlider \r\n\t\t\t\t\trange \r\n\t\t\t\t\tmin={xMinBound} \r\n\t\t\t\t\tmax={xMaxBound} \r\n\t\t\t\t\tbind:values={integralBoundsInput}\r\n\t\t\t\t\tstep={0.01}\r\n\t\t\t\t\tfloat \r\n\t\t\t\t\thover\r\n\t\t\t\t\tspringValues={{stiffness: 1, damping: 1 }}\r\n\t\t\t\t/>\t\r\n\t\t\t</span>\r\n\t\t\t\r\n\t\t\t<button class={rectangleStrategy === 'Left' ? 'highlighted' : ''}  on:click={_ => rectangleStrategy = 'Left'}>Left</button>\r\n\t\t\t<button class={rectangleStrategy === 'Midpoint' ? 'highlighted' : ''}  on:click={_ => rectangleStrategy = 'Midpoint'}>Midpoint</button>\r\n\t\t\t<button class={rectangleStrategy === 'Right' ? 'highlighted' : ''}  on:click={_ => rectangleStrategy = 'Right'}>Right</button>\t\r\n\t\t{/if}\r\n\t{:else}\r\n\t\t\t<h1>Early Calculus Supplement App</h1>\r\n\t\t\t<h2>Calculus Might Not Be Easy</h2>\r\n\t\t\t\t<p>But this app helps visualize the transition from finite to infinite\r\n\t\t\t\tso you have something to understand instead of just rules to memorize.</p>\r\n\t\t\t<h2>Credits</h2>\r\n\t\t\t\t<h3>Devlopers: \r\n\t\t\t\t\t<a href=\"https://github.com/schreiberbrett\">Brett Schreiber</a> and\r\n\t\t\t\t\t<a href=\"https://github.com/nchlsb\">Nick Brady</a> \r\n\t\t\t\t</h3>\r\n\t\t\t\t<h3>Calculs Tutors Conulsted: \r\n\t\t\t\t\t<a href=\"https://www.math.ucla.edu/~esserl/?fbclid=IwAR0lUHqLf1uoD5DgY1yz1i_zEYqAunsRI8QsSmMvilNgDQOeewqyWLS3prQ\">Louis Esser</a>, \r\n\t\t\t\t\tRichard Shaffer, and Steven Wood</h3>\r\n\t\t\t\t<h3> Introduced the Devs to Eachother: Cal Doughan</h3>\r\n\t\t\t\t<h3>\r\n\t\t\t\t\tInsperations:\r\n\t\t\t\t\t<a href=\"https://www.desmos.com/calculator\">Desmos</a> and\r\n\t\t\t\t\t<a href=\"https://www.youtube.com/watch?v=WUvTyaaNkzM\"> 3Blue1Brown</a> \r\n\t\t\t\t</h3>\r\n\t\t\t<h2>Source Code</h2>\r\n\t\t\t\t<a href=\"https://github.com/nchlsb/IntegralVisualizer\">Link to GitHub</a>\r\n\t{/if}\r\n\t<!-- <p id=\"differenceEquation1\"></p>\r\n\t<p id=\"differenceEquation2\"></p>\r\n\t<p id=\"differenceEquation3\"></p>\r\n\t<p id=\"differenceEquation4\"></p>\r\n\t<p id=\"differenceEquation5\"></p>\r\n\t<p id=\"xEquals\"></p>\r\n\t<p id=\"deltaXEquals\"></p> -->\r\n\t\r\n</div>\r\n</div>\r\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css\" integrity=\"sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X\" crossorigin=\"anonymous\">\r\n<style>\r\n\t.outer {\r\n\t\twidth: 100%;\r\n\t}\r\n\r\n\t.riemann-rectangle {\r\n\t\tfill: crimson;\r\n\t\tstroke: black;\r\n\t\tstroke-width: 1;\r\n\t}\r\n\r\n\t.riemann-rectangle-no-stroke {\r\n\t\tfill: crimson;\r\n\t\tstroke: crimson;\r\n\t\tstroke-width: 1;\r\n\t}\r\n\r\n\tline, rect, polyline {\r\n\t\tstroke-width: 1px;\r\n\t\tvector-effect: non-scaling-stroke;\r\n\t}\r\n\r\n\t@media (min-width: 640px) {\r\n\t\tmain {\r\n\t\t\tmax-width: none;\r\n\t\t}\r\n\t}\r\n\r\n\tinput[type=\"range\"], svg.cartesian {\r\n\t\twidth: min(65vh, 100%);\r\n\t\tdisplay: block;\r\n\t\tmargin: 0 auto;\r\n\t}\r\n\r\n\t.container {\r\n\t\twidth: min(70vh, 100%);\r\n\t\tdisplay: block;\r\n\t\tmargin: 0 auto;\r\n\t}\r\n\r\n\t/* Flip the vertical axis in <g> to emulate cartesian. */\r\n\tsvg.cartesian > g {\r\n\t\ttransform: scaleY(-1);\r\n\t}\r\n\r\n\t/* Re-flip all <text> element descendants to their original side up. */\r\n\tsvg.cartesian > g text {\r\n\t\ttransform: scaleY(-1);\r\n\t}\r\n\r\n\t.highlighted {\r\n\t\tbackground-color: limegreen;\r\n\t}\r\n\r\n\tlabel {\r\n\t\twidth: max-content;\r\n\t\tfont-size: 20px;\r\n\t}\r\n\r\n\t#AreaOfRectangles {\r\n\t\tcolor: crimson\r\n\t}\r\n\r\n\t/* .grayout {\r\n\t\topacity: 0.4;\r\n\t}\t */\r\n\r\n\t.slider {\r\n\t\t--range-handle-focus: rgb(177, 27, 57);\r\n\t\t--range-handle: rgb(177, 27, 57);\r\n\t\t--range-handle-inactive: rgb(177, 27, 57);\r\n\t\t--range-range: rgb(187, 187, 187);\r\n\t\t--range-range-inactive: rgb(187, 187, 187);\r\n\t}\r\n\r\n\t/* .equation {\r\n\t\tfont-size: 25px;\r\n\t} */\r\n\r\n\t@media screen and (min-width: 320px) {\r\n\t\t.equation {\r\n\t\t\tfont-size: calc(15px + 6 * ((100vw - 320px) / 680));\r\n\t\t}\r\n\t}\r\n\t\r\n\t@media screen and (min-width: 1000px) {\r\n\t\t.equation {\r\n\t\t\tfont-size: 30px;\r\n\t\t}\r\n\t} \t\r\n\r\n\t.integeralBound \r\n\t{\r\n\t\tfont-size: 0.25px;\r\n\t}\r\n\r\n\t.AxisLabel {\r\n\t\tfont-size: 0.25px;\r\n\t}\r\n\r\n</style>",
    "<script>\r\n\texport let title;\r\n\texport let x;\r\n\texport let y;\r\n</script>\r\n<div style=\"\r\n\t\ttop: {y + 5}px;\r\n\t\tleft: {x + 5}px;\">{title}</div>\r\n\r\n<style>\r\n\tdiv {\r\n\t\tborder: 1px solid #ddd;\r\n\t\tbox-shadow: 1px 1px 1px #ddd;\r\n\t\tbackground: white;\r\n\t\tborder-radius: 4px;\r\n\t\tpadding: 4px;\r\n\t\tposition: absolute;\r\n\t}\r\n</style>\r\n"
  ],
  "names": [],
  "mappings": "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"
}